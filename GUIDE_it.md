# Una guida al Code Vault di GitHub

## Introduzione

Questo archivio, GitHub Code Vault, è stato istituito dal GitHub Archive Program, la cui missione è preservare il software open source per le generazioni future. Potresti leggerlo tra un anno o mille, ma in ogni caso, speriamo che i suoi contenuti, e forse il concetto stesso di open source, ti siano utili.

Questo è principalmente un archivio di software. Il software è una serie di comandi utilizzati per controllare le azioni di un computer. Un computer è un dispositivo che può eseguire automaticamente funzioni matematiche così più velocemente di una mente umana da avere poteri ben oltre i nostri. I nostri computer sono usati per aiutare ad esplorare i segreti dell'universo, per connettere tutta l'umanità in una rete onnipresente di informazioni, per manipolare i segnali abbastanza velocemente da trasmettere suoni e proiettare immagini in movimento dettagliate su schermi elettrici e per controllare macchinari che superano di gran lunga sia la capacità che la precisione del lavoro umano.

Un computer senza software non può fare nessuna di queste cose. Un computer è una cosa straordinaria e meravigliosa, ma senza software tutta la sua potenza è inutile. Lo scopo di questo archivio è di trasmetterti ciò che sappiamo sul software.

Il software è scritto come sequenze di comandi complesse ma leggibili dall'uomo, le cui varie versioni sono note come linguaggi di programmazione, perché un'unità completa di software è spesso chiamata programma. Questi programmi vengono quindi convertiti nel linguaggio binario di uno e zero utilizzato dai computer. Questo processo è noto come compilazione.

Poiché il software compilato è molto difficile da decifrare nella sua forma di programma originale, nota anche come codice sorgente, è possibile che le persone mantengano segreta quella forma originale e rivendichino la proprietà su di essa. Il software open source non è un tipo diverso di software, ma un'etica diversa. L'etica open source rifiuta la segretezza e la proprietà. I programmi software open source sono messi a disposizione di chiunque voglia usarli, senza alcun costo, in modo che possano a loro volta migliorare quei programmi o usarli per costruire qualcosa di nuovo e migliore.

Un progetto open source è il lavoro collettivo di una comunità che si auto-organizza che può contare migliaia di individui. L'accumulo di tutti i progetti software open source qui archiviati è opera di una comunità di molti milioni. Sebbene alcuni individui possano avere diritti speciali all'interno di un determinato progetto, come la capacità di approvare o rifiutare le modifiche suggerite all'ultima versione ufficiale del suo codice sorgente, nessuno lo possiede mai. Ogni persona ha tutto il diritto di prendere e utilizzare una copia completa di qualsiasi progetto open source in qualsiasi momento, senza costi o penali. Questo è noto come fork di un progetto.

Quando molte persone lavorano contemporaneamente sul codice sorgente, è difficile tenere traccia e integrare tutte le loro modifiche. Un progetto open source noto come "Git" è dedicato alla risoluzione di questo problema. Integra una cronologia completa di tutte le aggiunte e modifiche a un progetto in un'entità nota come repository Git. Questo archivio è essenzialmente un archivio di tali repository.

Questo archivio è stato creato da una società denominata "GitHub", che fornisce un servizio che consente alle persone di tutto il mondo di memorizzare i programmi software che hanno scritto, tenere traccia delle modifiche a questi programmi e collaborare con altri per migliorarli ed espanderli. GitHub rende i suoi servizi disponibili gratuitamente agli sviluppatori di software open source pubblico. Ha decine di milioni di tali utenti.

Quello che segue è una descrizione di ciò che riteniamo sarà necessario sapere e avere per utilizzare al meglio questo archivio software. Se non conoscete o non comprendete nulla di tutto questo, non disperare! Abbiamo anche incluso una guida su come soddisfare questi requisiti. Se per qualsiasi motivo non potete realizzarli da soli, allora potranno farlo i vostri discendenti.

## Cosa ti serve per utilizzare l'archivio

In linea di principio, tutto ciò di cui hai bisogno per accedere ai contenuti di questo archivio è una fonte di illuminazione e una sorta di lente d'ingrandimento. Tuttavia, la maggior parte (anche se non tutti) dei suoi dati sono stati impacchettati molto strettamente su bobine di pellicola in una forma codificata e compressa. Lo stesso leggere, decodificare e decomprimere questi dati richiederà un considerevole calcolo. In teoria potrebbe essere fatto senza computer, ma sarebbe molto noioso e difficile.

La nostra aspettativa è che non abbiate bisogno delle nostre definizioni di software, computer e altri termini. Immaginiamo che abbiate computer propri, probabilmente di gran lunga più avanzati dei nostri, e forse con un'architettura fondamentalmente diversa. Dopo aver compreso la panoramica e la guida di seguito, sarete in grado di accedere facilmente a tutti i dati.

Tuttavia, è possibile che abbiate computer inferiori ai nostri o addirittura nessun computer. In caso di tale eventualità, abbiamo preparato una bobina di dati non compressa, non codificata e leggibile dall'uomo che chiamiamo Albero tecnologico. L'albero tecnologico contiene informazioni sulle nostre tecnologie fondamentali, i nostri computer e il nostro software, nella speranza che, nel tempo, sarai in grado di utilizzare questa conoscenza per ricreare computer che possono utilizzare il software open source in questo archivio.

## Cosa c'è dentro

L'archivio è così grande - circa 21 trilioni di byte (spiegato di seguito) - perché è estremamente inclusivo e democratico. Molti milioni di persone rendono disponibile a tutti il software che scrivono. Questo archivio include un'istantanea, ovvero una singola copia, in un singolo momento, di tutto il software pubblico che gli utenti di GitHub stanno attivamente sviluppando. Ciò significa che include milioni di repository separati. La nostra speranza è che questo approccio ampio e democratico possa interessare gli storici del futuro.

I repository inclusi in questo archivio sono stati determinati esclusivamente dall'ora dell'ultimo commit, ovvero dall'ultima volta che sono stati aggiornati e dal numero di stelle. (Gli utenti di GitHub sono tutti in grado di "contrassegnare" i repository pubblici, per indicare che sono di loro interesse o significato.) Lo snapshot è stato avviato il 02/02/2020, ovvero il secondo giorno del mese di febbraio dell'anno 2020 del calendario gregoriano, come noi contiamo il tempo. I repository inclusi in esso sono: tutti i repository con eventuali commit negli 80 giorni precedenti; tutti i repository con almeno una stella con eventuali commit nei 365 giorni precedenti; e tutti i repository con almeno 250 stelle, indipendentemente da quando sono stati aggiornati l'ultima volta.

Naturalmente, non tutti questi archivi sono ugualmente importanti in termini di influenza e dipendenze. L'albero tecnologico include un indice e una breve descrizione dei repository più significativi nell'archivio ed elenchi su cui è possibile trovare ciascuno di essi, in modo che sia possibile accedervi senza dover attraversare tutti questi milioni di repository per determinare quali sono i più utili nella pratica.

## Una panoramica dell'archivio

L'archivio è composto da 188 bobine di pellicola: una "bobina guida" di informazioni e guida leggibili dall'uomo, che chiamiamo Albero Tecnologico, e 187 bobine di software archiviato. Ogni bobina include 65.000 fotogrammi singoli. I fotogrammi all'inizio di ogni bobina e i fotogrammi della bobina guida includono testo e immagini leggibili dall'uomo. Tutti gli altri fotogrammi del film sono costituiti da dati digitali memorizzati in una forma visiva nota come codici QR.

Per dati digitali si intendono i dati memorizzati in definitiva in formato binario, cioè come 0 e 1, perché i computer stessi sono binari - controllati da segnali elettrici che sono "on" o "off", corrispondenti a 1 o 0 - e quindi i dati binari sono molto più facili da capire per i computer rispetto a qualsiasi altri.

I metadati leggibili dall'uomo memorizzati all'inizio di ogni bobina includono informazioni sul film stesso, una guida alla codifica QR utilizzata, un programma software per decodificarlo e un indice. L'indice elenca il titolo, il numero di fotogramma iniziale e il checksum per ogni file memorizzato su quella bobina.

Un file è una singola entità di dati coerente. Un checksum è un valore univoco di un calcolo, noto come funzione hash, eseguito sull'intero contenuto di un file, per garantire che il suo contenuto non sia stato danneggiato o corrotto; la funzione hash utilizzata nell'archivio è nota come "SHA-1".

Ogni codice QR è costituito da un campo di minuscoli quadrati bianchi o neri che occupano quasi l'intero fotogramma della pellicola. Utilizziamo i codici QR perché sono molto più compatti e robusti del testo leggibile dall'uomo. Un codice QR si decodifica in dati binari, cioè una serie di uno e zeri.

Questa decodifica è solo il primo passo per trasformare quei dati binari in informazioni significative. Sono dati compressi, il che significa che sono stati compattati per risparmiare spazio, in modo simile a come si potrebbe scrivere "128xA" piuttosto che scrivere la lettera A 128 volte. Dopo essere stato decodificato, deve essere decompresso.

Il risultato dopo la decompressione è noto come file di archivio: un singolo file contenente l'intero contenuto del repository di un singolo progetto software. La maggior parte dei repository include molti file, quindi questo file di archivio è come un libro che contiene molti capitoli separati o una scatola che contiene molte altre scatole. È generalmente vantaggioso, sebbene non assolutamente necessario, decomprimere il file di archivio nei file che lo compongono prima di accedervi.

Infine, ogni file componente è il proprio insieme di dati binari, ovvero uno e zero. Si può dare un senso ai dati se si conosce il loro formato. Ad esempio, nel formato noto come "UTF-8", il formato più comune in archivio, gli uno e gli zeri sono divisi in gruppi di otto, noti come byte, il byte 01000001 rappresenta la lettera A; i tre byte 01101001 01101110 01110100 rappresentano la parola int; ei due byte 11000011 10000011 rappresentano la lettera Ã (A con sopra un accento tilde).

Questo processo di archiviazione dei dati, file binari raccolti in file di archivio che sono stati prima compressi e poi codificati QR, è ovviamente complesso rispetto alla semplice scrittura di testo leggibile dall'uomo. Il processo di disarchiviazione che dovrai seguire -- da QR a binario compresso; da compresso a non compresso; da file di archivio a insieme di file; da file di testo a testo leggibile dall'uomo -- è altrettanto complesso. Questo perché tale complessità ci consente di archiviare molti più dati di quanto sarebbe altrimenti possibile, in un modo relativamente facile da leggere per un computer.

Se questa complessità vi risulta difficile e costosa, ci scusiamo, ma la nostra aspettativa è che, in tal caso, questa guida e l'Albero Tecnologico leggibile dall'uomo allevieranno tale complessità e potrebbero forse esservi più utili dell'archivio contenuti, almeno fino a quando i vostri computer non saranno sufficientemente avanzati da poter gestire facilmente la complessità dei dati dell'archivio.

## File, directory, repository e formati di dati

Può essere istruttivo discutere in che modo l'archivio è suddiviso logicamente. In particolare, è probabile che sia utile una discussione su file, directory e formati di dati.

Un file è una raccolta di dati raggruppati in un'entità coerente con un unico nome: pensa ai dati come sabbia e un file come una sorta di borsa che può contenere sabbia e solo sabbia. Una directory è una raccolta di file: pensala come una specie di borsa che può contenere solo altre borse. Seguendo questa metafora, ogni repository è costituito da una directory esterna, nota come directory root, che contiene un numero di file e/o un numero di directory. Ogni directory può, a sua volta, contenere sia i file che le directory stesse.

Questa struttura è preferita perché è molto più facile lavorare con file organizzati in gruppi rispetto a una singola raccolta di file. L'identificativo di un particolare file all'interno della directory esterna è costituito dai nomi di tutte le directory che lo racchiudono, a partire dalla radice, seguito dal proprio nome individuale, con un carattere / tra ogni nome. Ad esempio, un file denominato README.md nella directory principale sarebbe identificato come /README.md e un file identificato come /public/www/index.html sarebbe il file index.html nella directory 'www' all'interno della directory 'public' all'interno della directory root.

Ogni repository a sua volta ha due nomi, separati da un divisore, che nell'archivio è un carattere _ o trattino basso. (Storicamente è stata una / o barra, ma è anche usata per indicare una directory, quindi usiamo _ per chiarezza.) Il primo nome è l'account GitHub che possiede quel repository; il secondo è il nome del singolo repository. La combinazione di repository e identificatori di file può essere utilizzata per identificare in modo univoco un singolo file nell'archivio. Ad esempio, il file 'package.json' nella directory 'web' nel repository 'ykarma' all'interno dell'account GitHub 'rezendi' potrebbe essere identificato in modo univoco come /web/package.json in rezendi_ykarma nell'archivio.

Diversi tipi di file hanno scopi diversi. L'archivio GitHub è costituito principalmente da file di testo, ovvero file i cui dati sono destinati a rappresentare la lingua scritta. La maggior parte del software è scritta in file di testo contenenti testo altamente strutturato noto come codice sorgente. Un programma speciale noto come compilatore converte quel codice sorgente leggibile dall'uomo in istruzioni leggibili dal computer note come codice compilato o codice macchina.

I file che non sono file di testo, come i file che rappresentano immagini visive o contengono codice compilato, sono spesso indicati come file binari. Questo è purtroppo un termine fuorviante, poiché anche i file di testo consistono anch'essi di 1 e di 0. Faremo riferimento a file che non sono file di testo come file non-di-testo.

Esistono molti modi per rappresentare il linguaggio umano scritto utilizzando 1 e 0. Per ragioni storiche, la maggior parte del codice sorgente è stato originariamente scritto in quello che è noto come alfabeto latino. La scrittura latina ha 26 caratteri di base che vengono utilizzati per rappresentare parole pronunciabili, ciascuna delle quali ha due forme, maiuscole e minuscole. Ha anche 10 cifre per rappresentare i numeri. La scrittura latina, insieme a vari altri simboli associati usati per indicare la struttura e altri concetti, è codificata in 1 e 0 in un formato noto come 'ASCII', che può rappresentare 128 caratteri diversi e per ragioni storiche è stato dominante nella maggior parte dei software per molti anni.

Tuttavia, la scrittura latina è solo un piccolo sottoinsieme dei molti modi in cui gli esseri umani si esprimono nella lingua scritta. Per supportare altre scritture, consentendo anche a tutto il software che era stato scritto di utilizzare ASCII di continuare a lavorare senza modifiche (un concetto noto come compatibilità con le versioni precedenti), è stato introdotto un altro formato di dati noto come 'UTF-8'.

ASCII rimane il formato più comune di codice sorgente. Ogni bobina di questo archivio include una guida ai caratteri ASCII. ASCII è un sottoinsieme di UTF-8, vale a dire che anche tutte le codifiche ASCII sono codifiche UTF-8. La bobina guida contiene inoltre una specifica di tutti i caratteri UTF-8. Quasi tutti i file di testo in questo archivio dovrebbero essere codificati come UTF-8.

I file non-di-testo includono file destinati a rappresentare immagini e documenti formattati. Una convenzione ampiamente utilizzata prevede che i nomi dei file terminino con un '.' carattere seguito da un suffisso che indica il tipo di file. Ad esempio, un nome di file che termina con .jpg è probabilmente un file di immagine JPEG; quello che termina con .PNG è probabilmente un file di immagine Portable Network Graphic; e uno che termina con .pdf un file Portable Document Format.

Non esiste un singolo suffisso che indichi i file di testo. Piuttosto, per il codice sorgente, è più probabile che il suffisso indichi in quale linguaggio di programmazione o markup è scritto il codice. I linguaggi di programmazione e markup saranno descritti più dettagliatamente di seguito.

## Come estrarre i contenuti dell'archivio

Qui forniremo una panoramica su come decomprimere un particolare repository archiviato nei suoi vari file costituenti. Anche in questo caso, questo processo consiste in:

1. Identificazione della bobina e dei frame specifici su cui sono archiviati i dati del repository.

2. Decodifica dai codici QR, i campi di pixel neri, bianchi e grigi su quei frame, in un file binario, una sequenza di (almeno migliaia e spesso milioni di) 1 e 0.

3. Decomprimere il file binario in un file di archivio più lungo e non compresso.

4. Scindere il file di archivio nei file secondari separati che contiene. Si noti tuttavia che i dati di archivio sono generalmente comprensibili, sebbene disordinati, anche se questo passaggio viene omesso.

5. Infine, convertire ciascuno di quei sottofile -- sequenze di 1 e 0 che possono variare da molto brevi a molto lunghe -- in caratteri scritti, se sono file di testo.

### Identificazione della bobina e dei frame specifici su cui sono archiviati i dati del repository

Ogni bobina di pellicola inizia con una parte iniziale della pellicola vuota, quindi il fotogramma di riferimento zero, che consiste in un rettangolo nero pieno in un angolo di un fotogramma vuoto per la restante parte. Il prossimo frame leggibile dall'uomo è il Control Frame, con le informazioni sulla bobina. Di seguito è riportato il sommario, che a sua volta include un elenco di file di dati utente.

Ogni repository su questa bobina è uno di quei file di dati utente. L'elenco include un ID univoco, un ID file e un nome per ciascuno di questi file. Ad esempio, il repository CPython dell'account Python potrebbe avere l'ID file elencato come 12345 e il nome elencato come python_cpython.tar.

Di seguito all'elenco dei file di dati utente c'è un elenco di posizioni dei dati digitali. Questo elenco include l'ID del file, un frame iniziale, un byte iniziale, un frame finale e un byte finale. Quindi, usando l'ipotetico esempio CPython, l'elemento in questo elenco con l'ID 12345 potrebbe avere un frame iniziale di 054321, un byte iniziale di 03210321, un frame finale di 054545 e un byte finale di 12321232.

Ciò significa che, per ottenere i dati CPython: Vai al frame 54321 di questa bobina di pellicola. Decodificare tutti i frame dal frame iniziale, 54321, al frame finale, 54545, in valori binari, con i mezzi descritti di seguito. Questo ti darà 225 blocchi di dati numerati da 54321 a 54545, che inizieranno con una serie di blocchi vuoti senza dati. Elimina i primi 3210320 byte nel primo blocco di dati non vuoto. Aggiungi tutti i dati 'centrali', in ordine. Infine, aggiungi i primi 12321232 byte dall'ultimo blocco di dati, 54545. Ora hai assemblato il repository CPython completo, come un singolo file di archivio compresso.

### Decodifica dai codici QR in un file binario

I dettagli su come decodificare i fotogrammi del film in dati binari si trovano nelle Informazioni sulla Rappresentazione leggibili dall'uomo che si situate dopo l'indice all'inizio di ogni bobina di film nell'archivio. Questa informazione si trova su ogni bobina in modo che, anche se una singola bobina è separata dall'archivio, sarà comunque possibile decifrarne il contenuto. Tali Informazioni sulla Rappresentazione includono, in ordine:

1. Una guida al programma GitHub Archive (questo documento)

2. Indice descrittivo di GitHub, un elenco e una breve descrizione di tutti i repository su questa bobina

3. Descrizione delle Informazioni sulla Rappresentazione

4. Conservazione Digitale e Come Recuperare i Dati, una panoramica dei dettagli sul recupero dei dati

5. Descrizione del Supporto di Memorizzazione

6. Tecnologia di Recupero Dati

7. Struttura della Bobina di Conservazione Generica (formato bobina)

8. Descrizione del Formato del Frame 4K Generico

9. Descrizione della Libreria di Unboxing (per i codici QR)

10. Unboxing del codice sorgente della libreria

11. Specifica del formato dati ASCII

12. Specifica del linguaggio di programmazione C

13. Codice sorgente del file di archivio TAR

14. Codice sorgente PDF

15. Specifica del formato file XZ (per compressione / decompressione, descritto di seguito)

Il sesto di questi elementi, il documento Tecnologia di Recupero Dati, descrive i requisiti e i processi per utilizzare uno scanner per acquisire i dati su un singolo fotogramma di pellicola codificato digitalmente e trasformarlo in una forma suscettibile di analisi al computer. L'ottavo di essi, la Descrizione del Formato del Frame 4K Generico, fornisce le informazioni tecniche, incluso il codice sorgente, necessarie a un computer per acquisire un'immagine scansionata e convertirla in dati binari.

È teoricamente possibile, in linea di principio, convertire un repository da dati con codifica QR a dati binari senza utilizzare un computer. Tuttavia, sarebbe enormemente difficile e probabilmente richiederebbe uno sforzo considerevole da parte di una comunità ben organizzata per molte settimane, se non mesi o anni. Poiché i contenuti dei repository sono software destinati a essere eseguiti su un computer, il loro utilizzo in assenza di un computer sarebbe minimo nella migliore delle ipotesi.

Nel caso in cui gli eredi di questo archivio non abbiano computer, dovrebbero mantenere l'archivio intero e al sicuro fino a quando non li avranno. Uno degli scopi dell'albero tecnologico leggibile dall'uomo è quello di aiutare ad accelerare lo sviluppo di tecnologie e computer in caso di questa eventualità. (Il suo altro scopo è codificare la nostra tecnologia e il suo sviluppo per gli storici futuri).

### Decomprimere il file di archivio nei sottofile separati che contiene

Il file binario per ogni repository è in un formato noto come TAR, per Tape Archive. Un file TAR è essenzialmente composto raggruppando un numero di file insieme collegando la fine di uno all'inizio del successivo, come se si legassero insieme singoli pezzi di carta in un unico rotolo. Un file TAR può includere un numero qualsiasi di file, di qualsiasi dimensione, suddivisi in un numero qualsiasi di directory e sottodirectory.

Ogni sottofile all'interno di un file TAR è preceduto da un record di intestazione di 512 byte, che agisce come il nastro nella metafora dello scorrimento. Questo record di intestazione contiene informazioni sul file, come il nome e la dimensione. La fine dell'archivio è indicata da almeno due blocchi consecutivi di 512 byte.

Poiché i file TAR sono essenzialmente solo raccolte di file con record di testo tra di loro, se un file TAR contiene tutti i file di testo, può essere trattato come un file di testo stesso. Se contiene una miscela dei due tipi, può essere trattato come un file di testo che contiene una miscela di testo strutturato e significativo (i file di testo costituenti) e incomprensibili parole senza senso (i file non-di-testo costituenti).

È possibile annidare i file TAR all'interno di file TAR, un contenitore all'interno di un altro, ed è così che viene memorizzata la maggior parte dei nostri dati archiviati. Per ogni dato repository, il file TAR esterno conterrà almeno:

* un singolo file di metadati non compresso chiamato META, che include il nome del repository, il nome dell'account, la descrizione, la lingua, il conteggio delle stelle e il conteggio dei fork
* un file compresso (vedi sotto) denominato COMMITS, che include il registro delle modifiche apportate al repository nel tempo
* un file denominato repo.tar.xz, un file TAR compresso che contiene il contenuto effettivo del repository

Altri metadati, come wiki, pagine gh, problemi e richieste pull, possono anche essere inclusi come file compressi separati.

I dettagli specifici dei file TAR e il software per codificarli e decodificarli, possono essere trovati nelle Informazioni sulla Rappresentazione in ogni bobina dell'archivio.

### Decomprimere file compressi in file leggibili e non compressi

Per includere quanti più archivi e quanti più dati possibile, la maggior parte dei dati è stata compressa. Compressione significa utilizzare una piccola quantità di dati per rappresentare una quantità maggiore, utilizzando modelli e ripetizioni in quella quantità maggiore. Ad esempio, invece di scrivere il carattere per nove volte di seguito, si potrebbe semplicemente scrivere il testo compresso 9a, se si fosse certi che il lettore avrebbe capito che 9a significava il testo non compresso aaaaaaaaa.

Gli algoritmi di compressione efficaci sono molto più complessi di così, ma si applica lo stesso principio. Questo archivio utilizza un programma di compressione noto come 'XZ', che a sua volta utilizza un algoritmo noto come 'LZMA'. Il secondo file di dati in ogni bobina contiene il codice sorgente e la documentazione per XZ in un unico file di archivio TAR non compresso, descritto di seguito. (Il primo file di dati contiene la Dichiarazione Universale dei Diritti Umani in ogni lingua umana scritta disponibile).

LZMA combina ciò che è noto come algoritmo 'LZ77' e "codifica intervallo". LZ77 sostituisce i dati ripetuti con riferimenti alle precedenti apparizioni di quei dati. Ad esempio, per semplificare grossolanamente, se una frase di 80 byte appare due volte, a 400 byte di distanza, la seconda volta, l'algoritmo essenzialmente compatta i dati dicendo "ripeti 80 byte da 400 byte fa". La codifica dell'intervallo converte essenzialmente un intero messaggio in un unico numero molto lungo, che a sua volta può essere codificato.

I passaggi specifici dell'algoritmo da utilizzare per decomprimere i dati sono descritti dal codice sorgente XZ contenuto nel secondo file di dati in ogni bobina. Sebbene sia teoricamente possibile decomprimere a mano, ancora una volta, questo sarebbe un processo straordinariamente dispendioso in termini di tempo e lavoro. In pratica, sarebbe necessario un computer funzionante.

### Conversione di ogni singolo file in caratteri scritti

L'umanità ha utilizzato molti caratteri scritti nel corso dei millenni. La codifica utilizzata per rappresentare questi caratteri come 1 e 0 all'interno di questo archivio è nota come 'UTF-8'. Un singolo carattere UTF-8, ovvero un singolo simbolo scritto, può occupare da 1 a 4 byte di dati binari.

Per motivi storici, poiché erano i più utilizzati nel tempo e nella regione in cui e quando è iniziato lo sviluppo del software, un gruppo di caratteri (e concetti) noti come 'ASCII' sono codificati in modo più efficiente, a 1 byte per carattere. Tutto ciò che non è ASCII è codificato come 2 o più byte per carattere. La maggior parte dei file di testo in questo archivio sono ASCII, ma molti non lo sono. Molti altri saranno principalmente ASCII con caratteri occasionali non ASCII.

Le specifiche dettagliate di ASCII possono essere trovate nelle Informazioni di rappresentazione in ogni bobina dell'archivio. Le specifiche dettagliate di UTF-8 possono essere trovate nella bobina guida. Il primo file di dati su ogni bobina dell'archivio conterrà il testo della Dichiarazione universale dei diritti umani in ogni lingua umana scritta disponibile. Questo servirà sia come strumento di traduzione che come esempio di ASCII e UTF-8.

## Tipi di file

Esistono molti tipi diversi di file di testo, creati per motivi diversi. Il tipo principale qui, il motivo per cui esiste questo archivio, è il codice sorgente. Il codice sorgente è un testo molto denso ed estremamente strutturato, in cui simboli come '{' e ';' hanno una grande importanza.

La cosa fondamentale del codice sorgente è che è scritto per essere letto dai compilatori. Poiché i compilatori sono software, un altro modo di formulare questo è che il codice sorgente è scritto per essere letto dai computer. Un buon codice è scritto anche in modo che altri esseri umani, se sono esperti e istruiti nel campo del software, possano capirlo; ma è corretto solo se un compilatore può capirlo.

Quel compilatore, a sua volta, attraverso complicate sequenze descritte nell'Albero Tecnologico, convertirà il codice sorgente nelle sequenze di uno e zero che faranno eseguire al computer le funzioni e le attività descritte dal codice. Per fare un esempio molto semplice, la riga di codice

_for (int i=0; i<5; i++) {}_

sarà convertito dal compilatore in una serie di istruzioni binarie fornite al computer, che farà sì che una piccola parte del computer, chiamata registro, imposti il suo valore a 0, e successivamente incrementerà quel valore a 1, 2, 3 e poi 4. (Questo non è inteso come un esempio di codice utile; è solo un'illustrazione del processo a più livelli di trasformare il codice sorgente in software in esecuzione).

Altri tipi di file di testo, come JSON, XML e HTML, vengono utilizzati per memorizzare i dati (al contrario dei comandi) per i computer. Sono generalmente leggibili anche dagli esseri umani, sebbene i loro formati strutturati li rendano più difficili da leggere rispetto a testi di narrazione meno strutturati come questo file.

La maggior parte degli altri tipi di file di testo sono destinati ad essere eventualmente letti dagli esseri umani. Alcuni sono testo semplice, per lo più non strutturato, come questo file che stai attualmente leggendo. Un tipo che incontrerai ampiamente nell'archivio è Markdown, indicato dall'estensione .md di un file, che è una sorta di forma intermedia pensata per essere leggibile dagli umani nella sua forma grezza e anche, allo stesso tempo, strutturata in modo che i computer possono formattarli in layout visivamente più accattivanti e utili. La maggior parte dei repository in questo archivio ha un file Markdown README.md, che è generalmente inteso come un'introduzione iniziale al repository, descrivendo cos'è, perché esiste e come usarlo.

Può essere utile anche una breve panoramica delle forme più comuni di file non di testo. Il codice compilato non è testo. I file JPG e PNG codificano le immagini in formato digitale e MP3 e WAV codificano l'audio. I file PDF codificano i documenti con una formattazione precisa e perfetta. E i file ZIP e TAR, come accennato in precedenza, sono file contenitore che a loro volta possono includere uno o molti altri file.

## Linguaggi Umani e Linguaggi di Programmazione

### Lingue Umane

Ci sono migliaia di lingue scritte usate dall'umanità oggi e anche più lingue parlate. La maggior parte di queste sono usate solo da popolazioni relativamente piccole, ma ci sono almeno venti lingue usate come prima o seconda lingua da almeno 60 milioni di persone.

Le lingue più utilizzate al mondo sono l'inglese e il cinese. Per ragioni storiche, per molti anni la maggior parte dello sviluppo del software è avvenuto nelle nazioni anglofone, quindi per un certo periodo l'inglese è diventato la lingua predefinita del software. La maggior parte dei linguaggi di programmazione utilizza parole inglesi nella loro sintassi. È la lingua in cui è stata scritta per la prima volta questa guida all'archivio.

Non è garantito che gli eredi di questo archivio conoscano l'inglese, anche se sembra una lingua particolarmente probabile che duri indefinitamente. Nel caso in cui alcune indicazioni in altre lingue siano utili, includiamo le oltre 500 traduzioni disponibili della Dichiarazione Universale dei Diritti Umani come file UTF-8 non compresso all'inizio di ogni bobina e anche all'interno dell'Albero Tecnologico. Questa dichiarazione è un elenco dei diritti e delle libertà di ogni singolo essere umano nella nostra epoca, che non devono mai essere portati via.

### Linguaggi di Programmazione

I Linguaggi di Programmazione sono quelli utilizzati dagli esseri umani per comunicare le istruzioni ai computer. Sono le lingue in cui si esprime il software. Anche altri umani (istruiti) dovrebbero essere in grado di leggere il software scritto nei linguaggi di programmazione, ma questo è un obiettivo secondario.

Un linguaggio di programmazione è un insieme di elementi predefiniti, la maggior parte dei quali sono parole, che possono essere disposti in modo strutturato per istruire un computer a eseguire l'azione specificata nel modo specificato. Una raccolta di tali istruzioni è nota come programma o codice sorgente. Il codice sorgente è essenzialmente un software in una forma scritta congelata.

I programmi sono generalmente suddivisi in fasi distinte, note come istruzioni, che a loro volta sono raggruppate in raccolte note come funzioni. Un intero programma può essere contenuto in un singolo file o può essere distribuito su migliaia.

Esistono centinaia di linguaggi di programmazione diversi, distribuiti in molte forme, approcci e filosofie differenti. Alcuni vengono compilati in file binari separati, che vengono poi eseguiti; alcuni, conosciuti come linguaggi "interpretati", sono effettivamente compilati ed eseguiti tutti in una volta, senza una fase intermedia. La maggior parte dei linguaggi di programmazione moderni include librerie di funzioni pre-scritte e tali librerie possono essere molto voluminose ed elaborate. Alcuni dei linguaggi di programmazione più popolari di oggi sono:

- C, uno dei linguaggi più antichi e veloci, più universali e potenti, semplice per certi versi ma piuttosto limitato per altri, e non sempre intuitivo, facile da leggere o facile da imparare.

- C ++, un'evoluzione più complessa, astratta e potente di C.

- C #, un'ulteriore evoluzione compilata non in codice macchina binario ma in un "runtime" interpretato.

- Java, che è simile a (ma precede) C #, è forse il linguaggio più utilizzato oggi.

- JavaScript, piuttosto diverso da Java nonostante la somiglianza nel nome, e noto anche come 'ECMAScript', è un linguaggio inizialmente utilizzato interamente all'interno di un browser web, ovvero un programma che recupera, interpreta e visualizza i dati da un computer remoto noto come Internet server; oggi, però, è ampiamente utilizzato anche su quei server.

- TypeScript, una forma di JavaScript con regole più rigide in modo che gli errori, noti anche come bug, abbiano meno probabilità di essere introdotti nei programmi.

- Python, un linguaggio elegante popolare tra gli scienziati, potente e un buon primo linguaggio.

- Ruby, un linguaggio intuitivo le cui dichiarazioni spesso si leggono quasi come l'inglese scritto.

- Go, un linguaggio semplice e potente che eccelle soprattutto nei programmi paralleli, cioè programmi scritti in modo tale che più funzioni vengano eseguite indipendentemente allo stesso tempo.

- Swift, un nuovo linguaggio utilizzato per scrivere per i telefoni e altri dispositivi utilizzati da un miliardo di persone.

- Rust, inteso come sostituto di C, che rende molto meno probabili i bug pericolosi.

- PHP, un linguaggio semplice utilizzato per i server Internet.

- Lisp, un linguaggio molto antico con un approccio fondamentalmente diverso alla programmazione basato sulle funzioni.

- SQL, un tipo di linguaggio molto diverso utilizzato per recuperare i dati da archivi di dati strutturati e altamente efficienti noti come database.

- Assembler (o assembly), una famiglia di linguaggi molto criptica, limitata, ma veloce e potente in cui esiste una relazione diretta tra i costrutti del linguaggio e il codice macchina del computer in questione; può essere considerato codice compilato a metà.

## Sviluppo, Dipendenze e Open Source

### Sviluppo

Il processo di prendere un singolo, semplice file di codice sorgente e convertirlo in impulsi elettrici all'interno di un computer è estremamente complesso. Affrontiamo questa complessità utilizzando livelli di astrazione. Un'astrazione nota come set di istruzioni consente di utilizzare l'output del codice macchina da un singolo compilatore su molti tipi diversi di computer. Un autore di codice sorgente di solito non ha bisogno di sapere o preoccuparsi di quale tipo di computer, o anche quale set di istruzioni, sarà usato per eseguire quel codice; questo viene estratto dal compilatore.

Il software moderno è, a sua volta, molto più complesso di un singolo autore che lavora su un singolo programma per un singolo computer. È composto da molti autori che lavorano su molti file all'interno di un singolo progetto, contemporaneamente, spesso utilizzando più linguaggi di programmazione. Inoltre, ogni progetto dipende da altri progetti separati e autonomi come strumenti e/o componenti, mentre questi progetti sono essi stessi attivamente elaborati e dipendono a loro volta da altri progetti. Far lavorare insieme tutte queste parti mobili in modo elegante ed efficiente è la sfida dello sviluppo del software moderno.

Quando più autori di codice sorgente, noti anche come sviluppatori di software, lavorano su un singolo progetto, ognuno ha il proprio computer e una copia dell'intero progetto sul proprio computer. Se ognuno di loro apporta modifiche, ognuno ha una versione diversa dello stesso progetto. Il processo di riconciliazione di più versioni di un progetto è noto come controllo della versione. È gestito dal software di controllo della versione; in questo archivio, dal software chiamato Git, da cui prende il nome GitHub stesso. Ogni repository in questo archivio è un repository Git.

Git può unire automaticamente diverse versioni del software in una forma coerente con un intervento umano minimo richiesto. Git mantiene anche una cronologia completa che ti consente di tornare a una versione precedente come e quando necessario. Tuttavia, per risparmiare spazio, i repository di questo archivio generalmente non includono le cronologie Git.








Quando più sviluppatori accettano un progetto su più percorsi diversi contemporaneamente, ciò è noto come diramazione di un progetto e quei percorsi sono noti come rami. Il ramo principale concordato di un progetto è noto come trunk o ramo principale. Git fornisce una struttura che gli sviluppatori possono utilizzare per riassumere le differenze tra due rami e proporre di unire i loro a quelli dell'altro. Questa operazione è nota come richiesta pull. Lo sviluppo del software moderno consiste in gran parte nel ramificare un progetto, scrivere o modificare il software sul tuo ramo e, al termine, inviare una richiesta pull affinché il tuo lavoro venga reincorporato nel ramo principale.

### Dipendenze

Essenzialmente ogni linguaggio di programmazione supporta la costruzione sul lavoro di altri. Senza riutilizzare il lavoro degli altri, ogni progetto sarebbe enormemente più difficile e molto più lento, e solo una parte infinitesimale di progetti arriverebbe ad essere utilizzata nel mondo reale.

Se il progetto A deve includere il progetto B affinché A possa svolgere il suo lavoro, allora A è noto come dipendente dal progetto B e B è noto come dipendenza del progetto A. A può avere molte dipendenze, ognuna delle quali può avere molte dipendenze dipendenze proprie e così via. Inoltre, ogni dipendenza è per una particolare versione, o gamma di versioni, di un dato progetto. L'elemento completo di tutti i più livelli di dipendenze di un progetto è noto come albero delle dipendenze.

Generalmente, le dipendenze sono dettagliate all'interno dei file del codice sorgente, di solito all'inizio, e ogni volta che il compilatore o l'interprete trova una dipendenza, la cerca in un insieme di directory predefinite. Poiché l'albero delle dipendenze per un progetto può essere molto complesso, a volte è dettagliato nella sua interezza in un singolo file all'interno di un progetto noto come elenco di pacchetti. Ad esempio, i progetti Ruby possono avere un Gemfile per questo scopo, mentre i progetti JavaScript possono avere un file package.json. Ciò consente a un tipo di strumento noto come software di gestione dei pacchetti di recuperare tutte le dipendenze di un progetto contemporaneamente, da uno o più server Internet.

Nel caso di questo archivio, è probabile che le dipendenze per un dato progetto esistano altrove nell'archivio. Per trovare una dipendenza nell'archivio, è necessario prima scoprire il nome della dipendenza nel codice sorgente o nell'elenco dei pacchetti, i cui dettagli esatti variano in base alla lingua e al framework, quindi utilizzare l'indice principale nella bobina guida, oppure, in sua assenza, gli indici nella parte anteriore di ogni bobina, per determinare su quale bobina e frame si trova il repository in questione.

### Open source

Poiché l'esecuzione di un programma su un computer richiede solo il codice macchina compilato, è possibile distribuirlo mantenendo segreto il codice sorgente. Questo è noto come modello closed source. Agli albori dell'informatica, il codice sorgente era solitamente distribuito insieme al suo codice macchina, ma successivamente, quando il software è diventato un settore redditizio, il modello closed source è diventato più comune.

Da allora si è appreso che rendere pubblico il codice sorgente, affinché chiunque possa copiarlo, ramificarlo e migliorarlo, è un approccio molto più efficace allo sviluppo del software. Più persone in grado di leggere il codice sorgente di un progetto significa più persone che identificano possibili esigenze e nuove funzionalità utili, più persone che comprendono il progetto abbastanza da contribuire ad esso, più persone che potrebbero individuare bug e inviare correzioni e più persone per testare e verificare che quel nuovo codice funzioni.

In generale, il closed source porta a comunità più piccole, isolate e frammentate che lottano per trovare e adottare idee nuove e migliori. L'open source porta a comunità ampie e interconnesse, che aiutano a vicenda i progetti a crescere, prosperare e avere successo, utilizzando il lavoro degli altri come dipendenze e/o riutilizzando il proprio codice e imparando l'uno dall'altro. Il software open source è un kit di strumenti per l'uso collettivo di tutta l'umanità, e più strumenti e migliori abbiamo, più velocemente e meglio possiamo progredire come specie.
