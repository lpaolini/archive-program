# Una guida al Code Vault di GitHub

## Introduzione

Questo archivio, GitHub Code Vault, è stato istituito dal GitHub Archive Program, la cui missione è preservare il software open source per le generazioni future. Potresti leggerlo tra un anno o mille, ma in ogni caso, speriamo che i suoi contenuti, e forse il concetto stesso di open source, ti siano utili.

Questo è principalmente un archivio di software. Il software è una serie di comandi utilizzati per controllare le azioni di un computer. Un computer è un dispositivo che può eseguire automaticamente funzioni matematiche così più velocemente di una mente umana da avere poteri ben oltre i nostri. I nostri computer sono usati per aiutare ad esplorare i segreti dell'universo, per connettere tutta l'umanità in una rete onnipresente di informazioni, per manipolare i segnali abbastanza velocemente da trasmettere suoni e proiettare immagini in movimento dettagliate su schermi elettrici e per controllare macchinari che superano di gran lunga sia la capacità che la precisione del lavoro umano.

Un computer senza software non può fare nessuna di queste cose. Un computer è una cosa straordinaria e meravigliosa, ma senza software tutta la sua potenza è inutile. Lo scopo di questo archivio è di trasmetterti ciò che sappiamo sul software.

Il software è scritto come sequenze di comandi complesse ma leggibili dall'uomo, le cui varie versioni sono note come linguaggi di programmazione, perché un'unità completa di software è spesso chiamata programma. Questi programmi vengono quindi convertiti nel linguaggio binario di uno e zero utilizzato dai computer. Questo processo è noto come compilazione.

Poiché il software compilato è molto difficile da decifrare nella sua forma di programma originale, nota anche come codice sorgente, è possibile che le persone mantengano segreta quella forma originale e rivendichino la proprietà su di essa. Il software open source non è un tipo diverso di software, ma un'etica diversa. L'etica open source rifiuta la segretezza e la proprietà. I programmi software open source sono messi a disposizione di chiunque voglia usarli, senza alcun costo, in modo che possano a loro volta migliorare quei programmi o usarli per costruire qualcosa di nuovo e migliore.

Un progetto open source è il lavoro collettivo di una comunità che si auto-organizza che può contare migliaia di individui. L'accumulo di tutti i progetti software open source qui archiviati è opera di una comunità di molti milioni. Sebbene alcuni individui possano avere diritti speciali all'interno di un determinato progetto, come la capacità di approvare o rifiutare le modifiche suggerite all'ultima versione ufficiale del suo codice sorgente, nessuno lo possiede mai. Ogni persona ha tutto il diritto di prendere e utilizzare una copia completa di qualsiasi progetto open source in qualsiasi momento, senza costi o penali. Questo è noto come fork di un progetto.

Quando molte persone lavorano contemporaneamente sul codice sorgente, è difficile tenere traccia e integrare tutte le loro modifiche. Un progetto open source noto come "Git" è dedicato alla risoluzione di questo problema. Integra una cronologia completa di tutte le aggiunte e modifiche a un progetto in un'entità nota come repository Git. Questo archivio è essenzialmente un archivio di tali repository.

Questo archivio è stato creato da una società denominata "GitHub", che fornisce un servizio che consente alle persone di tutto il mondo di memorizzare i programmi software che hanno scritto, tenere traccia delle modifiche a questi programmi e collaborare con altri per migliorarli ed espanderli. GitHub rende i suoi servizi disponibili gratuitamente agli sviluppatori di software open source pubblico. Ha decine di milioni di tali utenti.

Quello che segue è una descrizione di ciò che riteniamo sarà necessario sapere e avere per utilizzare al meglio questo archivio software. Se non conosci o non capisci nulla di tutto questo, non disperare! Abbiamo anche incluso una guida su come soddisfare questi requisiti. Se per qualsiasi motivo non potete realizzarli da soli, allora potranno farlo i vostri discendenti.

## Cosa ti serve per utilizzare l'archivio

In linea di principio, tutto ciò di cui hai bisogno per accedere ai contenuti di questo archivio è una fonte di illuminazione e una sorta di lente d'ingrandimento. Tuttavia, la maggior parte (anche se non tutti) dei suoi dati sono stati impacchettati molto strettamente su bobine di film in una forma codificata e compressa. Lo stesso leggere, decodificare e decomprimere questi dati richiederà un considerevole calcolo. In teoria potrebbe essere fatto senza computer, ma sarebbe molto noioso e difficile.

La nostra aspettativa è che non abbiate bisogno delle nostre definizioni di software, computer e altri termini. Immaginiamo che abbiate computer propri, probabilmente di gran lunga più avanzati dei nostri, e forse con un'architettura fondamentalmente diversa. Dopo aver compreso la panoramica e la guida di seguito, sarete in grado di accedere facilmente a tutti i dati.

Tuttavia, è possibile che abbiate computer inferiori ai nostri o addirittura nessun computer. In caso di tale eventualità, abbiamo preparato una bobina di dati non compressa, non codificata e leggibile dall'uomo che chiamiamo Albero tecnologico. L'albero tecnologico contiene informazioni sulle nostre tecnologie fondamentali, i nostri computer e il nostro software, nella speranza che, nel tempo, sarai in grado di utilizzare questa conoscenza per ricreare computer che possono utilizzare il software open source in questo archivio.

## Cosa c'è dentro

L'archivio è così grande - circa 21 trilioni di byte (spiegato di seguito) - perché è estremamente inclusivo e democratico. Molti milioni di persone rendono disponibile a tutti il ​​software che scrivono. Questo archivio include un'istantanea, ovvero una singola copia, in un singolo momento, di tutto il software pubblico che gli utenti di GitHub stanno attivamente sviluppando. Ciò significa che include milioni di repository separati. La nostra speranza è che questo approccio ampio e democratico possa interessare gli storici del futuro.

I repository inclusi in questo archivio sono stati determinati esclusivamente dall'ora dell'ultimo commit, ovvero dall'ultima volta che sono stati aggiornati e dal numero di stelle. (Gli utenti di GitHub sono tutti in grado di "contrassegnare" i repository pubblici, per indicare che sono di loro interesse o significato.) Lo snapshot è stato avviato il 02/02/2020, ovvero il secondo giorno del mese di febbraio, in l'anno 2020 del calendario gregoriano, come contiamo il tempo. I repository inclusi in esso sono: tutti i repository con eventuali commit negli 80 giorni precedenti; tutti i repository con almeno una stella con eventuali commit nei 365 giorni precedenti; e tutti i repository con almeno 250 stelle, indipendentemente da quando sono stati aggiornati l'ultima volta.

Naturalmente, non tutti questi archivi sono ugualmente importanti in termini di influenza e dipendenze. L'albero tecnologico include un indice e una breve descrizione dei repository più significativi nell'archivio ed elenchi su cui è possibile trovare ciascuno di essi, in modo che sia possibile accedervi senza dover attraversare tutti questi milioni di repository per determinare quali sono i più pratici utile.

## Una panoramica dell'archivio

L'archivio è composto da 188 bobine di pellicola: una "bobina guida" di informazioni e guida leggibili dall'uomo, che chiamiamo Albero tecnologico, e 187 bobine di software archiviato. Ogni bobina include 65.000 fotogrammi singoli. I fotogrammi all'inizio di ogni bobina e i fotogrammi della bobina guida includono testo e immagini leggibili dall'uomo. Tutti gli altri fotogrammi del film sono costituiti da dati digitali memorizzati in una forma visiva nota come codici QR.

Per dati digitali si intendono i dati memorizzati in definitiva in formato binario, cioè come 0 e 1, perché i computer stessi sono binari - controllati da segnali elettrici che sono "on" o "off", corrispondenti a 1 o 0 - e quindi i dati binari sono molto più facili da capire per i computer rispetto a qualsiasi altro.

I metadati leggibili dall'uomo memorizzati all'inizio di ogni bobina includono informazioni sul film stesso, una guida alla codifica QR utilizzata, un programma software per decodificarlo e un indice. L'indice elenca il titolo, il numero di fotogramma iniziale e il checksum per ogni file memorizzato su quella bobina.

Un file è una singola entità di dati coerente. Un checksum è un valore univoco di un calcolo, noto come funzione hash, eseguito sull'intero contenuto di un file, per garantire che il suo contenuto non sia stato danneggiato o corrotto; la funzione hash utilizzata nell'archivio è nota come "SHA-1".

Ogni codice QR è costituito da un campo di minuscoli quadrati bianchi o neri che occupano quasi l'intero fotogramma della pellicola. Utilizziamo i codici QR perché sono molto più compatti e robusti del testo leggibile dall'uomo. Un codice QR si decodifica in dati binari, cioè una serie di uno e zeri.

Questa decodifica è solo il primo passo per trasformare quei dati binari in informazioni significative. Sono dati compressi, il che significa che sono stati compattati per risparmiare spazio, in modo simile a come si potrebbe scrivere "128xA" piuttosto che scrivere la lettera A 128 volte. Dopo essere stato decodificato, deve essere decompresso.

Il risultato dopo la decompressione è noto come file di archivio: un singolo file contenente l'intero contenuto del repository di un singolo progetto software. La maggior parte dei repository include molti file, quindi questo file di archivio è come un libro che contiene molti capitoli separati o una scatola che contiene molte altre scatole. È generalmente vantaggioso, sebbene non assolutamente necessario, decomprimere il file di archivio nei file componenti prima di accedervi.

Infine, ogni file componente è il proprio set di dati binari, ovvero uno e zero. Si può dare un senso ai dati se si conosce il loro formato. Ad esempio, nel formato noto come "UTF-8", il formato più comune in archivio, gli uno e gli zeri sono divisi in gruppi di otto, noti come byte, il byte 01000001 rappresenta la lettera A; i tre byte 01101001 01101110 01110100 rappresentano la parola int; ei due byte 11000011 10000011 rappresentano la lettera Ã (A con un accento tilde in alto).

Questo processo di archiviazione dei dati, file binari compressi in file di archivio che sono stati prima compressi e poi codificati QR, è ovviamente complesso rispetto alla semplice scrittura di testo leggibile dall'uomo. Il processo di disarchiviazione che dovrai seguire: da QR a binario compresso; da compresso a non compresso; da file di archivio a più file; da file di testo a testo leggibile dall'uomo - è altrettanto complesso. Questo perché questa complessità ci consente di archiviare molti più dati di quanto sarebbe altrimenti possibile, in un modo relativamente facile da leggere per un computer.

Se questa complessità è difficile e costosa per voi, ci scusiamo, ma la nostra aspettativa è che, in tal caso, questa guida e l'albero tecnologico leggibile dall'uomo allevieranno questa complessità e potrebbero forse esservi più utili dell'archivio contenuti, almeno fino a quando i vostri computer non saranno sufficientemente avanzati da poter gestire facilmente la complessità dei dati dell'archivio.

## File, directory, archivi e formati di dati

Può essere istruttivo discutere in che modo l'archivio è suddiviso logicamente. In particolare, è probabile che sia utile una discussione su file, directory e formati di dati.

Un file è una raccolta di dati raggruppati in un'entità coerente con un unico nome: pensa ai dati come sabbia e un file come una sorta di borsa che può contenere sabbia e solo sabbia. Una directory è una raccolta di file: pensala come una specie di borsa che può contenere solo altre borse. Seguendo questa metafora, ogni repository è costituito da una directory esterna, nota come directory root, che contiene un numero di file e/o un numero di directory. Ogni directory può, a sua volta, contenere sia i file che le directory stesse.

Questa struttura è preferita perché è molto più facili lavorare con file organizzati in gruppi rispetto a una singola raccolta di file. L'identificativo di un particolare file all'interno della directory esterna è costituito dai nomi di tutte le directory che lo racchiude, a partire dalla radice, seguito dal proprio nome individuale, con un carattere / tra ogni nome. Ad esempio, un file denominato README.md nella directory principale sarebbe identificato come /README.md e un file identificato come /public/www/index.html sarebbe il file index.html nella directory 'www' all'interno della directory 'public' all'interno della directory root.

Ogni repository a sua volta ha due nomi, separati da un divisore, che nell'archivio è un carattere _ o trattino basso. (Storicamente è stata una / o barra, ma è anche usata per indicare una directory, quindi usiamo _ per chiarezza.) Il primo nome è l'account GitHub che possiede quel repository; il secondo è il nome del singolo repository. La combinazione di repository e identificatori di file può essere utilizzata per identificare in modo univoco un singolo file nell'archivio. Ad esempio, il file 'package.json' nella directory 'web' nel repository 'ykarma' all'interno dell'account GitHub 'rezendi' potrebbe essere identificato in modo univoco come /web/package.json in rezendi_ykarma nell'archivio.

Diversi tipi di file hanno scopi diversi. L'archivio GitHub è costituito principalmente da file di testo, ovvero file i cui dati sono destinati a rappresentare la lingua scritta. La maggior parte del software è scritta in file di testo contenenti testo altamente strutturato noto come codice sorgente. Un programma speciale noto come compilatore converte quel codice sorgente leggibile dall'uomo in istruzioni leggibili dal computer note come codice compilato o codice macchina.

I file che non sono file di testo, come i file che rappresentano immagini visive o contengono codice compilato, sono spesso indicati come file binari. Questo è purtroppo un termine fuorviante, poiché anche i file di testo consistono in definitiva di 1 e 0. Faremo riferimento a file che non sono file di testo come file non di testo.

Esistono molti modi per rappresentare il linguaggio umano scritto utilizzando 1 e 0. Per ragioni storiche, la maggior parte del codice sorgente è stato originariamente scritto in quello che è noto come alfabeto latino. La scrittura latina ha 26 caratteri di base che vengono utilizzati per rappresentare parole pronunciabili, ciascuna delle quali ha due forme, maiuscole e minuscole. Ha anche 10 cifre per rappresentare i numeri. La scrittura latina, insieme a vari altri simboli associati usati per indicare la struttura e altri concetti, è codificata in 1 e 0 in un formato noto come 'ASCII', che può rappresentare 128 caratteri diversi e per ragioni storiche è stato dominante nella maggior parte dei software per molti anni .

Tuttavia, la scrittura latina è solo un piccolo sottoinsieme dei molti modi in cui gli esseri umani si esprimono nella lingua scritta. Per supportare altri script, consentendo anche a tutto il software che era stato scritto di utilizzare ASCII di continuare a lavorare senza modifiche (un concetto noto come compatibilità con le versioni precedenti), è stato introdotto un altro formato di dati noto come "UTF-8".

ASCII rimane il formato più comune di codice sorgente. Ogni bobina di questo archivio include una guida ai caratteri ASCII. ASCII è un sottoinsieme di UTF-8, vale a dire che anche tutte le codifiche ASCII sono codifiche UTF-8. La bobina guida contiene inoltre una specifica di tutti i caratteri UTF-8. Quasi tutti i file di testo in questo archivio dovrebbero essere codificati come UTF-8.

I file non di testo includono file destinati a rappresentare immagini e documenti formattati. Una convenzione ampiamente utilizzata prevede che i nomi dei file terminino con un "." carattere seguito da un suffisso che indica il tipo di file. Ad esempio, un nome di file che termina con .jpg è probabilmente un file di immagine JPEG; quello che termina con .PNG è probabilmente un file di immagine Portable Network Graphic; e uno che termina con .pdf un file Portable Document Format.

Non esiste un singolo suffisso che indichi i file di testo. Piuttosto, per il codice sorgente, è più probabile che il suffisso indichi in quale linguaggio di programmazione o markup è scritto il codice. I linguaggi di programmazione e markup saranno descritti più dettagliatamente di seguito.
